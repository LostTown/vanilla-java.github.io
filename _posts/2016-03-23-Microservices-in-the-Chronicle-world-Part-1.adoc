= Microservices in the Chronicle world - Part 1
:hp-tags: microservices, examples

At a high level, Microservices have a lot in common.  They subscribe to the same ideals.
When it comes to the details of how they are actually implemented, they can vary.

Microservices in the Chronicle world are designed around

* simplicity, simple is fast, flexiable and easier to maintain.
* transparent, you can't control what you don't understand.
* reproducablity, must be in your design to ensure a quality solution.

=== What do we mean by simple?

A key part of the microservices design is how messages are passed between services/components. The simplest messages could be called *asynchronous method calls*.

An asynchronous method call is one which

* doesn't return anything.
* doesn't alter it's arguments.
* doesn't throw any exceptions. (Although the underlying transport could)

The reason this approach is used, is that the simplest transport is no transport at all.  One component calls another.  This is not only fast (with inlining might not take any time at all), but it is simple to setup, debug and profile.  For most unit tests you don't need a real transport so there is no advantage in making the test more complicated than it need to be.

=== Lets look at an example

Say we have a service/component which is taking incremental market data updates. In the simplest case, this could be a market update with only one side, a buy or a sell.  The component could transform this into a full market update combining both the buy and sell price and quantity.

.Our inbound data structure
[source, java]
----
public class SidedPrice extends AbstractMarshallable {
    String symbol;
    long timestamp;
    Side side;
    double price, quantity;

    public SidedPrice(String symbol, long timestamp, Side side, double price, double quantity) {
        this.symbol = symbol;
        this.timestamp = timestamp;
        this.side = side;
        this.price = price;
        this.quantity = quantity;
    }
}
----

.Our outbound data structure
[source, java]
----
public class TopOfBookPrice extends AbstractMarshallable {
    String symbol;
    long timestamp;
    double buyPrice, buyQuantity;
    double sellPrice, sellQuantity;

    public TopOfBookPrice(String symbol, long timestamp, double buyPrice, double buyQuantity, double sellPrice, double sellQuantity) {
        this.symbol = symbol;
        this.timestamp = timestamp;
        this.buyPrice = buyPrice;
        this.buyQuantity = buyQuantity;
        this.sellPrice = sellPrice;
        this.sellQuantity = sellQuantity;
    }
    
    // more methods <1>
}
----
<1> For the complete code https://github.com/Vanilla-Java/Microservices/blob/master/src/main/java/net/openhft/samples/microservices/TopOfBookPrice.java[TopOfBookPrice.java]

The component which takes one sided prices could have an interface

[source, java]
----
public interface SidedMarketDataListener {
    void onSidedPrice(SidedPrice sidedPrice);
}
----

and it's output also has one method

[source, java]
----
public interface MarketDataListener {
    void onTopOfBookPrice(TopOfBookPrice price);
}
----

=== What does our microservice look like?

At a high level, the combiner is very simple

[source, java]
----
public class SidedMarketDataCombiner implements SidedMarketDataListener {
    final MarketDataListener mdListener;
    final Map<String, TopOfBookPrice> priceMap = new TreeMap<>();

    public SidedMarketDataCombiner(MarketDataListener mdListener) {
        this.mdListener = mdListener;
    }

    public void onSidedPrice(SidedPrice sidedPrice) {
        TopOfBookPrice price = priceMap.computeIfAbsent(sidedPrice.symbol, TopOfBookPrice::new);
        if (price.combine(sidedPrice))
            mdListener.onTopOfBookPrice(price);
    }
}
----

It implements our input interface and take the output interface as a listener.

=== What does AbstractMarshallable provide?

The https://github.com/OpenHFT/Chronicle-Wire/blob/master/src/main/java/net/openhft/chronicle/wire/AbstractMarshallable.java[AbstractMarshallable] class is a conveience class which implements `toString()`, `equals(Object)` and `hashCode()`. It also supports Marshallable's `writeMarshallable(WireOut)` and `readMarshallable(WireIn)`

The default implementations use all the non-static non-transient fields to either print, compare or build a hashCode.  Note: the resulting toString() can always be de-serialized with `Marshallable.fromString(CharSequence)`

Let's look at a couple of examples

[source, java]
----
SidedPrice sp = new SidedPrice("Symbol", 123456789000L, Side.Buy, 1.2345, 1_000_000);
assertEquals("!SidedPrice {\n" +
        "  symbol: Symbol,\n" +
        "  timestamp: 123456789000,\n" +
        "  side: Buy,\n" +
        "  price: 1.2345,\n" +
        "  quantity: 1000000.0\n" +
        "}\n", sp.toString());

// from string
SidedPrice sp2 = Marshallable.fromString(sp.toString());
assertEquals(sp2, sp);
assertEquals(sp2.hashCode(), sp.hashCode());
----

As you can see, the `toString()` is in YAML, concise and readable to a human and in code.

[source, java]
----
TopOfBookPrice tobp = new TopOfBookPrice("Symbol", 123456789000L, 1.2345, 1_000_000, 1.235, 2_000_000);
assertEquals("!TopOfBookPrice {\n" +
        "  symbol: Symbol,\n" +
        "  timestamp: 123456789000,\n" +
        "  buyPrice: 1.2345,\n" +
        "  buyQuantity: 1000000.0,\n" +
        "  sellPrice: 1.235,\n" +
        "  sellQuantity: 2000000.0\n" +
        "}\n", tobp.toString());

// from string
TopOfBookPrice topb2 = Marshallable.fromString(tobp.toString());
assertEquals(topb2, tobp);
assertEquals(topb2.hashCode(), tobp.hashCode());
}
----

One of the advantages of using this format is that it makes it easier to find the reason for a failing test even in complex objects.

.Even in a trivial test it's not obvious what the problem is
[source,java]
----
TopOfBookPrice tobp = new TopOfBookPrice("Symbol", 123456789000L, 1.2345, 1_000_000, 1.235, 2_000_000);
TopOfBookPrice tobp2 = new TopOfBookPrice("Symbol", 123456789000L, 1.2345, 1_000_000, 1.236, 2_000_000);

assertEquals(tobp, tobp2);
----
However when you run this test in your IDE, you get a comparison window.

.Comparison Windows in your IDE
image::TopOfBookPrice-comparison.png[Top Of Book Price comparison, 720]

If you have a large nested/complex object where `assertEquals` fails, it can really save you a lot of time finding what the discrepency is.


=== Testing our component

TBD

=== Mocking our component

TBD

=== Performance testing our component

TBD

=== Source for examples

https://github.com/Vanilla-Java/Microservices/tree/master/src/main/java/net/openhft/samples/microservices



